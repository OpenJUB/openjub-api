#!/usr/bin/env node

var program = require('commander');
var mongoose = require('mongoose');
var colors = require('colors');
var ldapjs = require('ldapjs');
var prompt = require('prompt');
var inquirer = require('inquirer');
var ldap = ldapjs.createClient({url:'ldap://jacobs.jacobs-university.de'});
var modelImport = require('../lib/models');
var pkg = require('../package');
var settings = require('../settings');

program
  .version(pkg.version)
  .option('-d, --drop', 'Delete Old Records')
  .option('-u, --username [username]', 'Username')
  .option('-p, --password [password]', 'Password')
  .parse(process.argv);

var Models; // holds all models available

function setup (callback) {
  console.log('INFO'.cyan + ' Creating connection to database');

  mongoose.connect(settings.database)
  Models = modelImport(mongoose);

  console.log('OK'.green + ' Connection established');

  var user, password;

  var questions = [];

  if (program.username) {
    user = program.username;
  }
  else {
    questions.push({
      type: 'input',
      name: 'username',
      message: 'CampusNet username',
      validate: function (value) {
        var pass = value.length !== 0;
        if (pass) {
          return true;
        } else {
          return 'Please Enter a Username'
        }
      }
    });
  }

  if (program.password) {
    password = program.password;
  }
  else {
    questions.push({
      type: 'password',
      name: 'password',
      message: 'CampusNet password',
      validate: function (value) {
        var pass = value.length !== 0;
        if (pass) {
          return true;
        } else {
          return 'Please Enter a Password'
        }
      }
    });
  }

  inquirer.prompt(questions, function (answers) {
    user = user || answers.username;
    password = password || answers.password;

    ldap.bind(user+'@'+settings.ldap.host, password, function(err) {
      if (!(err === null)) {
        console.log('ERR'.red + " Couldn't login with the details provided");
        process.exit(-1);
      }

      callback();
    });

    return;

  });

};

function drop () {
  console.log('WARN'.yellow + ' Dropping all entries in the database');

  Models.Student.remove(function(err) {
    if (!(err === null)) {
      console.log('ERR'.red + ' Failed to remove the students. Error: ' + err);
    }
  });

  Models.Course.remove(function(err) {
    if (!(err === null)) {
      console.log('ERR'.red + ' Failed to remove the courses. Error: ' + err);
    }
  });

  console.log('OK'.green + ' All data dropped');
  return;
};

function update () {
  console.log('INFO'.cyan + ' Updating all entries in database');
  var studentsDone, coursesDone;

  //first get the students
  getStudents(function(count, errors) {
    console.log('INFO'.cyan + ' Students retrieved (total: '+count +', errors: '+errors+')');
    studentsDone = 1;

    //and then the courses
    getCourses(function(count, errors) {
      console.log('INFO'.cyan + ' Courses retrieved (total: '+count+', errors:  '+errors+')');
      coursesDone = 1;
      cleanup(studentsDone, coursesDone);
    });
  });



  return;
};

function cleanup(s,c) {
  if (!s || !c) {
    return;
  }

  console.log('OK'.green + ' All entries updated');
  ldap.unbind(function(err) {
    if (!(err === null)) {
      console.log('ERR'.red + " Couldn't unbind from LDAP (nothing will probably happen, but bad nonetheless)");
    }
  });

  process.exit();
};


function getStudents(callback) {

  var alphabet = "abcdefghijklmnopqrstuvwxyz";
  var for_count = 0;
  var count = 0;
  var errors = 0;
  var block = 0;

  //we don't want to have mroe than one query at a time as that might result in bugs.
  var iteration = function(i){
    if(i <= alphabet.length){
      var opts = {
        filter: '(sAMAccountName='+alphabet[i]+'*)',
        scope: 'sub'
      };

      ldap.search('OU=Users,OU=CampusNet,DC=jacobs,DC=jacobs-university,DC=de', opts, function(err,search) {

        if (!(err === null)) {
          console.log('ERR'.red + " Couldn't retrieve students from LDAP. Error: " + err);
        }

        search.on('searchEntry', function (entry) {
          block++;
          var obj = parseStudent(entry.object);

          if (obj === null) {
            console.log('WARN'.yellow + " Student can't be parsed. Ignoring..");
            errors++;
            block--;
            return;
          }

          Models.PhoneRoom.findOne({'phone':obj.phone}, function (err, entry) {
            if (err) {
              console.log('ERR'.red + " Couldn't retrieve room. Error: " + err);
            }
            if (entry) {
              obj.room = entry.room;
            } else {
              obj.room = '';
            }
            count++;
            save_student(obj, function(){
              block--;
            });
          });
        });

        search.on('end', function(result) {
          if (++for_count == alphabet.length) {
            var next = function(){
              if(block > 0){
                return setTimeout(next, 1000);
              }
              callback(count, errors);
            }

            next();

          } else {
            iteration(i+1); //next iteration after the end. scripts/cd
          }
        });
      });
    }
  };

  iteration(0);
};

function getCourses(callback) {

  var alphabet = "0123456789AJ";
  var for_count = 0;
  var count = 0;
  var errors = 0;
  var block = 0;

  //make sure we only have one query at a time.
  var iteration = function(i){
    if(i < alphabet.length){
      var opts = {
        filter: '(CN=GS-CAMPUSNET-COURSE-'+alphabet[i]+'*)',
        scope: 'sub'
      };

      ldap.search('OU=Groups,OU=CampusNet,DC=jacobs,DC=jacobs-university,DC=de', opts, function(err,search) {
        if (!(err === null)) {
          console.log('ERR'.red + " Couldn't retrieve the courses from LDAP. Error: " + err);
        }

        search.on('searchEntry', function (entry) {
          block++;
          var obj = parseCourse(entry.object);

          if (obj === null) {
            console.log('WARN'.yellow + " Course can't be parsed. Ignoring..");
            errors++;
            block--;
            return;
          }

          count++;
          save_course(obj, function(){
            block--;
          });
        });

        search.on('end', function(result) {
          if (++for_count == alphabet.length) {
            var next = function(){
              if(block > 0){
                return setTimeout(next, 1000);
              }
              callback(count, errors);
            }

            next();
          } else {
            iteration(i+1);
          }
        });
      });
    }
  };

  iteration(0);

};

function save_course(obj, callback) {
  Models.Course.update({number: obj.number}, obj, {upsert: true}, function (err) {
    if (!(err === null)) {
      console.log('ERR'.red + ' Failed to update/insert the student with error: ' + err);
    }

    callback();
  });
}

function save_student(obj, callback) {
  Models.Student.update({username: obj.username}, obj, {upsert: true}, function (err) {
    if (!(err === null)) {
      console.log('ERR'.red + ' Failed to update/insert the student with error: ' + err);
    }

    callback();
  });
}

function parseStudent(obj) {
  var result = {};

  var name = obj.displayName.split(", ");

  if (!name) {
    // No name, ignoring..
    return null;
  }

  result.firstName = name[1];
  result.lastName = name[0];
  result.fullName = result.firstName + ' ' + result.lastName;
  result.eid = obj.employeeID;
  result.username = obj.sAMAccountName;


  if (!result.username || !result.firstName || !result.lastName || !result.eid) {
    // Mandatory fields are missing!
    return null;
  }

  result.type = obj.employeeType;
  if (!result.type) {
    result.type = "";
  }

  result.email = obj.mail;
  if (!result.email) {
    result.email = "";
  }

  result.major = obj.extensionAttribute3;
  if (!result.major) {
      result.major = "";
  }

  result.country = obj.extensionAttribute5;
  if (!result.country) {
    result.country = "";
  }

  result.description = obj.extensionAttribute2;
  if (!result.description) {
    result.description = "";
  }

  result.phone = obj.telephoneNumber;
  if (!result.phone) {
    result.phone = "";
  }

  result.description = result.description.replace(/int /g, 'int_');
  result.description = result.description.replace(/class /g, '');
  var description = result.description.replace(/\(.*\)/g, '');
  description = description.split(' ');
  if (description.length >= 2) {
    result.status = parseStatus(description[0]);
    result.year = parseInt(description[1], 10);
    result.year = isNaN(result.year) ? '' : result.year.toString();
    result.majorShort = description.slice(2).join(' ').trim();
  } else {
    result.year = '';
    result.majorShort = '';
    result.status = '';
  }


  result.college = parseCollege(obj.houseIdentifier);

  //result.room = ... - need to create a map phone->room
  //result.courses = obj.memberOf; - too ugly, needs parsing of some sort.
  return result;
};

function parseCollege(obj) {
  if (obj === "Alfried Krupp College") {
    return "Krupp";
  }
  else if (obj === "College III") {
    return "C3";
  }
  else if (obj === "College Nordmetall") {
    return "Nordmetall";
  }
  else if (obj === "Mercator College") {
    return "Mercator";
  }
  else {
    return "";
  }
}

function parseStatus(status) {
  status = status.toLowerCase();
  if (status === 'ug') {
    return 'undergrad';
  } else if (status === 'm') {
    return 'master';
  } else if (status === 'fy') {
    return 'foundation-year';
  } else if (status === 'phd') {
    return 'phd';
  } else if (status === 'int_phd') {
    return 'phd-integrated';
  } else {
    return '';
  }
}

function parseCourse(obj) {
  var result = {};

  var regex = /\(.+\)/;
  var matches = regex.exec(obj.description);

  if (!matches) {
    // Could not parse the name of the course, ignoring...
    return null;
  }

  var name = matches[0];
  name = name.slice(1,name.length-1);

  result.name = name;
  result.number = obj.displayName.replace("GS-CAMPUSNET-COURSE-","");

  return result;
}

(function main () {
  setup(function() {
    if (program.drop) {
      drop();
    }

    update();
  });
  return;
})();
